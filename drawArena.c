#include <stdio.h>
#include <stdlib.h>
#include "graphics.h"
#include "globals.h"
#include "drawArena.h"

int GRID_SIZE = 30;
int MINROWCOL = 7;
int MAXROWCOL = 15;
int NUMROWS;
int NUMCOLS;
// Using #define for SIZE ensures that it always represents the current product of NUMROWS and NUMCOLS,
// even if these values are changed later in the code. This keeps SIZE consistent with their current values.
#define SIZE (NUMROWS * NUMCOLS)

int randArenaSize(){
    return randomNum(MINROWCOL, MAXROWCOL);
}

void initialiseGlobals(){
    NUMROWS = 15;
    NUMCOLS = 10;
}

//this function was generated by copilot
void printTiles(Tile *tile, int rows, int columns){
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < columns; c++) {
            int index = r * columns + c;
            printf("Tile at (%d, %d): x = %d, y = %d, type = %c , index = %d\n", r, c, tile[index].x, tile[index].y, tile[index].type, tile[index].index);
        }
    }
}

void drawTiles(Tile *tile){
    background();
    setColour(gray);
    for(int i = 0; i < SIZE; i++){
        int x = tile[i].x;
        int y = tile[i].y;
        char type = tile[i].type;
        if(type == 'w'){
            //wall
            drawOneTile(x, y, blue);
        } else if(type == 'm'){
            //marker
            drawOneTile(x, y, red);
        } else if(type == 'o'){
            //obstacle
            drawOneTile(x, y, black);
        } else{
            //tile
            drawRect(x, y, GRID_SIZE, GRID_SIZE);
        }
    }
}

void drawOneTile(int x, int y, colour colour){
    setColour(colour);
    fillRect(x, y, GRID_SIZE, GRID_SIZE);
    setColour(gray);
}

void createUniqueTiles(Tile *tile, int numTiles, char type){
    int tilesDrawn = 0;
    while(tilesDrawn != numTiles){
        int index = randomNum(NUMCOLS + 1, NUMCOLS*(NUMROWS-1) - 2);
            //check we're on a tile
            if(tile[index].type == 't'){
                tile[index].type = type;
                tilesDrawn += 1;
            }
    }
}

void replaceFreeTile(Tile curTile){
    background();
    setColour(red);
    fillRect(curTile.x, curTile.y, GRID_SIZE, GRID_SIZE);
}

void replaceMarker(Tile curTile){
    background();
    setColour(white);
    fillRect(curTile.x, curTile.y, GRID_SIZE, GRID_SIZE);
    setColour(gray);
    drawRect(curTile.x, curTile.y, GRID_SIZE, GRID_SIZE);
}

void appendArray(Tile *tile, int r, int c, Tile curTile){
    //append 3 elements
    int index = r * NUMCOLS + c;
    tile[index].x = curTile.x;
    tile[index].y = curTile.y;
    tile[index].type = curTile.type;
    tile[index].index = curTile.index;
}

//function to fill a 2d array with elements, where each element is an array with [x, y, typeOfTile]
void createTiles(Tile *tile, int rows, int columns){
    //initial x and y pos
    int x = CANVAS_WIDTH/5;
    int y = CANVAS_HEIGHT/5;
    int i = 0;

    for(int r = 0; r < rows; r++){
    
        for(int c = 0; c < columns; c++){
            //top wall
            if(r == 0 || r == rows - 1){
                Tile curTile = {x, y, 'w', i};
                appendArray(tile, r, c, curTile);
                x += GRID_SIZE;
                i++;
            }
            else{ 
                if(c == 0 || c == columns - 1){
                    //left and right wall
                    Tile curTile = {x, y, 'w', i};
                    appendArray(tile, r, c, curTile);
                    i++;
                } else{
                    //tiles between walls
                    Tile curTile = {x, y, 't', i};
                    appendArray(tile, r, c, curTile);
                    i++;
                }
                x += GRID_SIZE;
            }
        }
        //move to next row
        x = CANVAS_WIDTH/5;
        y += GRID_SIZE;
    }

    tile[2*NUMCOLS + 1].type = 'm';
    //can't draw obstacle nor wall but can draw marker idk why
    createUniqueTiles(tile, 2, 'o');

}


Tile* drawArena(){
    initialiseGlobals(); // Initialise NUMROWS and NUMCOLS
    //allocate memory for an array of structs
    Tile *arenaTiles = (Tile*)malloc(SIZE * sizeof(Tile));

    createTiles(arenaTiles, NUMROWS, NUMCOLS);
    // printTiles(arenaTiles, NUMROWS, NUMCOLS);
    drawTiles(arenaTiles);
    return arenaTiles;
}

